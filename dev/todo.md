# Todo

> [!TIP]
> 本文件为开发备忘录... @todo

## 零、临时架构

```cpp
爬取侧: py 爬虫, 通过命令参数驱动
    - 纯命令行使用
    - [x] 作为服务程序启动 (方便进程间通信)

// 客户端: C++ QT, 发送命令给爬取侧, 爬取侧返回进度

前端: React (TS), 发送命令给爬取侧, 爬取侧返回进度 (Docker 版本)

// ======================================================= //

py 爬取流程: [使用后向爬取] https://github.com/HengXin666/BiLiBiLi_DanMu_Crawling/issues/14

    *0. 输入爬取的日期范围 [左边界, 右边界] -> 当前日期 = 右边界

    1. 爬取 [当前日期] 的历史弹幕

    2. 解析历史弹幕中 [非保护弹幕] 的弹幕中, 最早的时间

    3. 从该日期继续爬取

    *4. 如果 [当前日期 < 左边界] 则爬取结束, 否则 goto {1.}

    *5. 如果用户选择爬取全弹幕, 则无需设置 [爬取的日期范围]

        > 自动从当前日期开始爬取, 直到 {爬取 [当前日期] 的历史弹幕} -> 0 条弹幕

        然后进入[弹幕跟踪服务](需要开启): 间隔一段时间(可设置) 会爬取实时弹幕池
    
    最终产生内容: [注意, 一次爬取任务对应一个配置]
        1. 配置文件(.json), 存放本次爬取任务的配置, 包含:
            配置文件id (需要唯一, 因为cid可能重复(用户创建多个一样的爬取任务), 不能仅通过它来区分)
            爬取的视频的 cid
            爬取的视频标题
            最后一次进行爬取的时间
            爬取区间 [L, R]
            当前爬取的时间 (当且仅当 爬取 历史弹幕 有效)
            总弹幕条数, 高级弹幕(含代码弹幕/Bas弹幕)条数
            爬取状态 {
                正在爬取历史弹幕,
                暂停爬取历史弹幕,
                爬取历史弹幕被封禁中,
                正在爬取实时弹幕,
                暂停爬取实时弹幕,
                实时弹幕弹幕被封禁中,
            }

        2. 弹幕mid 文件, 该文件用于去重弹幕, 并且文件仅记录mid, 以简化解析策略

        3. 弹幕元信息存放文件, 一个弹幕数据的临时存放文件, 非 xml 文件; 应该是 sql 存储

            > 用户可以选择导出弹幕, 此时会生成一个完整的 xml 文件

    总配置文件:
        仅记录 cookies (cookie 的 list)
        爬取时间间隔区间 [int, int] (单位: 秒)
    
    所有内容记录在
        当前程序目录下(跨平台的), 的 reqData 文件夹

    特别情况: [[爬取番剧 / 多p]]

        策略: 首先, 全部都是以列表形式返回的, 所以我们可以统一处理:
        1. 在 reqData 下创建 文件夹 {用户命名 / 自动命名(当前时间 + 随机数)}
        2. 依据用户选择, 然后创建下面 3 个文件
            {cid}_config.json // 当前配置文件
            {cid}_dm_data.db  // 弹幕元数据
            {cid}_dm_id.db    // 弹幕唯一id数据
        3. 进行顺序爬取: 完成一个任务后才继续完成下一个任务

    展示:
        遍历 reqData 文件夹可以得到 所有任务列表
            里面的子文件夹就是子任务了
        如:

        任务:
          |- 炮姐番剧
          |     | - 01-电脑配件
          |     | - 02- ...
          |    ...
          |- 现代C++
                | - 01- xxx

爬取阶段:
    爬取 BAS 弹幕专包 -> 爬取历史弹幕 (从新到旧) -> 结束
    
    // @todo
    // 特别的, 要求前端和后端都校验, 保证是已经爬取完毕历史弹幕
    // 因为此后的历史弹幕只能往后更新, 不能前向更新, 如:
/*
    其中: - 表示有弹幕的日期, 
         x 表示已经爬取, 
         | 表示左右边界, 
         n 表示 new, 即新增的弹幕的日期
         <-- 表示爬取的方向, 即从新到旧 (2009年 <-- 2025年)
    |----------xxxxxxxxx|nnnnnnnnn
              ^ <--
        爬取到这里

    选择 [补充 爬取历史弹幕] 后
    ----------xxxxxxxxx|nnnnnnnnn|
                                 ^ <--
                            从这里开始重新爬取
    因此会丢失前面的弹幕, 所以必须要 爬取完历史弹幕, 才允许 [补充 爬取历史弹幕]

    同理, 检测实时弹幕 也应该在 爬取完毕历史弹幕的不久后, 才可以使用,
    如果间隔太久 (> 1 天), 则应该 先进行 [补充 爬取历史弹幕] 再进入 [检测实时弹幕] 模式
*/
    结束后, 提供两种选择:
        1. 补充 爬取历史弹幕 (用于长时间没有爬取, 又不希望重新爬取)
            - (1) 扫描本地弹幕数据库中最晚(最新)的弹幕的日期. 作为 [L, R] 的 L
            - (2) 重置配置文件的 currentTime 字段为 0 或者如果用户设置了 右边界 (R) 则取 min(R, 当前时间)
        2. 检测实时弹幕
            - 通过以小时 (应该补充为配置文件的配置项) (全局配置 and 个别配置) 为间隔
            - 爬取实时弹幕, 按照视频分片. 这样获取到的弹幕池是以 视频的 6 min 为区间获取的
            - 如果一天中新增的弹幕过多, 比如这天新增了 1w 条弹幕, 那显然是不可能完全出现在历史弹幕池的
            - 有弹幕被溢出而丢弃了. 而实时弹幕池就可以很好的爬取到 (应该)
```